# -*- coding: utf-8 -*-
# Generated by quantum-cli-sdk: ${generated_date}
from fastapi import FastAPI, HTTPException, BackgroundTasks, Query
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any, Union
import json
import logging
import os
import uuid
from datetime import datetime
import asyncio
import time
import sys
from collections import Counter

# --- Service Configuration ---
DEFAULT_CIRCUIT_FILENAME = "${default_circuit_filename}"
CIRCUITS_DIR = "circuits"
RESULTS_DIR = "results"
SERVICE_TITLE = "${app_name}"
SERVICE_DESCRIPTION = "${app_description}"
SERVICE_VERSION = "${app_version}"

# --- Logging Setup ---
log_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log_handler_stdout = logging.StreamHandler(sys.stdout)
log_handler_stdout.setFormatter(log_formatter)
# Optional file handler (consider volume mapping in Docker)
# log_handler_file = logging.FileHandler("microservice.log")
# log_handler_file.setFormatter(log_formatter)

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO) # Default level
logger.addHandler(log_handler_stdout)
# logger.addHandler(log_handler_file)

import sys # Add import
logger.info(f"Initial sys.path: {sys.path}") # Log sys.path

# --- Backend Availability & SDK Import Handling ---
QISKIT_AVAILABLE = False
qiskit = None
QuantumCircuit = None
qasm2_loads = None
QASM2ParseError = None
AerSimulator = None
SDK_BACKENDS_AVAILABLE = True # Assume True initially, set False on critical import error

try:
    # Try importing Qiskit
    import qiskit
    from qiskit import QuantumCircuit
    from qiskit.qasm2 import loads as qasm2_loads, QASM2ParseError
    try:
        # Correct import for Qiskit 1.0+
        from qiskit_aer import AerSimulator
        QISKIT_AVAILABLE = True
    except ImportError:
        logger.warning("qiskit installed, but qiskit-aer not found or failed to import. Qiskit backend unavailable.")
except ImportError:
    logger.debug("Qiskit not available.")
    pass

CIRQ_AVAILABLE = False
cirq = None
cirq_qasm = None
try:
    import cirq
    import cirq_qasm
    CIRQ_AVAILABLE = True
except ImportError:
    logger.debug("Cirq not available.")
    pass

BRAKET_AVAILABLE = False
braket = None
BraketCircuit = None
LocalSimulator = None
try:
    import braket
    from braket.circuits import Circuit as BraketCircuit # Alias to avoid name clash
    from braket.devices import LocalSimulator
    BRAKET_AVAILABLE = True
except ImportError:
    logger.debug("Braket not available.")
    pass

# --- FastAPI App Initialization ---
app = FastAPI(
    title=SERVICE_TITLE,
    description=SERVICE_DESCRIPTION,
    version=SERVICE_VERSION
)

# --- Pydantic Models ---
class CircuitRequest(BaseModel):
    circuit: Optional[str] = Field(None, description="QASM 2.0 circuit string. If None, uses the default circuit bundled with the service.")
    parameters: Optional[Dict[str, Any]] = Field(None, description="Parameters for the circuit (key-value pairs). Basic substitution is used.")
    shots: int = Field(1024, gt=0, description="Number of measurement shots.")
    simulator: str = Field("qiskit", description="Simulator backend ('qiskit', 'cirq', 'braket').")
    blocking: bool = Field(False, description="If true, wait for completion and return results directly. If false, return job ID immediately.")

class JobStatus(BaseModel):
    job_id: str
    status: str = Field(description="Job status: QUEUED, RUNNING, COMPLETED, FAILED")
    created_at: str
    simulator: str
    shots: int

class ResultsResponse(BaseModel):
    job_id: str
    status: str
    counts: Optional[Dict[str, int]] = Field(None, description="Measurement counts as {bitstring: count}")
    execution_time_sec: Optional[float] = Field(None, description="Approximate execution time in seconds.")
    error: Optional[str] = Field(None, description="Error message if the job failed.")

# --- In-Memory Job Store ---
# NOTE: This is simple and volatile. For production, use a persistent store (DB, Redis, etc.)
jobs: Dict[str, dict] = {}

# --- Directory Setup ---
os.makedirs(CIRCUITS_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)

# --- Default Circuit Path ---
default_circuit_path = os.path.join(CIRCUITS_DIR, DEFAULT_CIRCUIT_FILENAME)

# --- Helper Functions ---
def load_circuit_qasm(circuit_str: Optional[str]) -> str:
    """Loads QASM string, defaulting to the bundled circuit if None."""
    if circuit_str:
        # Basic validation (can be expanded)
        if "OPENQASM 2.0;" not in circuit_str:
            raise ValueError("Input does not look like a valid QASM 2.0 string.")
        return circuit_str
    else:
        if not os.path.exists(default_circuit_path):
            logger.error(f"Default circuit file not found at expected path: {default_circuit_path}")
            raise FileNotFoundError("Default circuit file not found at expected path.")
        try:
            with open(default_circuit_path, 'r') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Failed to read default circuit file {default_circuit_path}: {e}")
            raise IOError(f"Failed to read default circuit file: {e}")

# --- API Endpoints ---
@app.post("/run", status_code=202, response_model=JobStatus)
async def run_circuit_endpoint(request: CircuitRequest, background_tasks: BackgroundTasks):
    """Submit a quantum circuit for execution."""
    # Validate simulator choice against available backends
    if request.simulator == "qiskit" and not QISKIT_AVAILABLE:
        raise HTTPException(status_code=400, detail="Qiskit backend selected but not available.")
    if request.simulator == "cirq" and not CIRQ_AVAILABLE:
        raise HTTPException(status_code=400, detail="Cirq backend selected but not available.")
    if request.simulator == "braket" and not BRAKET_AVAILABLE:
        raise HTTPException(status_code=400, detail="Braket backend selected but not available.")
    if request.simulator not in ["qiskit", "cirq", "braket"]:
        raise HTTPException(status_code=400, detail=f"Unsupported simulator: {request.simulator}")

    # Load circuit (handles default case)
    try:
        circuit_qasm = load_circuit_qasm(request.circuit)
    except (ValueError, FileNotFoundError, IOError) as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Generate a unique job ID
    job_id = str(uuid.uuid4())
    created_time = datetime.utcnow().isoformat() + "Z"

    # Store job metadata (volatile)
    # Save circuit to a temporary file for the background task
    temp_circuit_file_path = os.path.join(CIRCUITS_DIR, f"job_{job_id}_circuit.qasm")
    try:
        with open(temp_circuit_file_path, "w") as f:
            f.write(circuit_qasm)
    except IOError as e:
        logger.error(f"Failed to write temporary circuit file for job {job_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to save circuit file for processing.")

    jobs[job_id] = {
        "job_id": job_id,
        "status": "QUEUED",
        "created_at": created_time,
        "simulator": request.simulator,
        "shots": request.shots,
        "parameters": request.parameters, # Store parameters if needed by task
        "circuit_path": temp_circuit_file_path, # Path to the saved circuit
        "results": None,
        "error": None
    }

    # Add the execution task to the background
    background_tasks.add_task(execute_circuit_task, job_id)
    logger.info(f"Job {job_id} QUEUED for execution on {request.simulator} simulator.")

    return JobStatus(**jobs[job_id]) # Return initial status

@app.get("/status/{job_id}", response_model=JobStatus)
async def get_job_status(job_id: str):
    """Get the status of a specific job."""
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    # Return relevant fields for status
    return JobStatus(
        job_id=job["job_id"],
        status=job["status"],
        created_at=job["created_at"],
        simulator=job["simulator"],
        shots=job["shots"]
    )

@app.get("/results/{job_id}", response_model=ResultsResponse)
async def get_job_results(job_id: str):
    """Get the results of a specific job."""
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    if job["status"] == "QUEUED" or job["status"] == "RUNNING":
        raise HTTPException(status_code=400, detail=f"Job status is {job['status']}. Results not yet available.")

    # Construct response
    response_data = {
        "job_id": job["job_id"],
        "status": job["status"],
        "counts": None,
        "execution_time_sec": None,
        "error": job.get("error")
    }

    # Extract results if job completed successfully
    job_results = job.get("results")
    if job["status"] == "COMPLETED" and job_results and isinstance(job_results, dict):
        response_data["counts"] = job_results.get("counts")
        response_data["execution_time_sec"] = job_results.get("execution_time_sec")
        # Potentially add backend_metadata if desired in the response

    return ResultsResponse(**response_data)

# --- Background Execution Task & Helpers ---
async def execute_circuit_task(job_id: str):
    """The actual task that runs the simulation using imported SDK backends."""
    job = jobs.get(job_id)
    if not job: logger.error("[Task:%s] Job info not found.", job_id); return
    if job["status"] != "QUEUED": logger.warning("[Task:%s] Status is %s, expected QUEUED. Skipping.", job_id, job["status"]); return

    # Import backend functions *inside* the task
    try:
        # Log the path of the SDK package being used
        import quantum_cli_sdk
        logger.debug(f"[Task:{job_id}] Attempting to import simulation backends from SDK located at: {quantum_cli_sdk.__file__}")

        from quantum_cli_sdk.commands.simulation_backends import (
            run_qiskit_simulation,
            run_cirq_simulation,
            run_braket_simulation
        )
        from quantum_cli_sdk.models import SimulationResult
        sdk_backends_imported = True
        logger.info(f"[Task:{job_id}] Successfully imported SDK simulation backends.")
    except ImportError as sdk_import_error:
        logger.error(f"[Task:{job_id}] Failed to import simulation backends from SDK within task: {sdk_import_error}", exc_info=True)
        job["status"] = "FAILED"
        job["error"] = "SDK Simulation backends failed to import."
        sdk_backends_imported = False

    if not sdk_backends_imported:
        logger.error("[Task:%s] SDK backends not available. Failing job.", job_id)
        return

    logger.info("[Task:%s] Starting execution on %s simulator via SDK backend.", job_id, job['simulator'])
    job["status"] = "RUNNING"
    start_time = time.time()
    sim_result: Optional[SimulationResult] = None
    error_message = None

    try:
        circuit_path = job["circuit_path"]
        # parameters = job["parameters"] or {} # Parameter handling might be needed by backend funcs?
        shots = job["shots"]
        simulator_name = job["simulator"]

        if not os.path.exists(circuit_path):
             raise FileNotFoundError(f"Job circuit file not found: {circuit_path}")

        # --- Select and Run Simulator Backend Function ---
        backend_func = None
        if simulator_name == "qiskit" and QISKIT_AVAILABLE:
             backend_func = run_qiskit_simulation
        elif simulator_name == "cirq" and CIRQ_AVAILABLE:
             backend_func = run_cirq_simulation
        elif simulator_name == "braket" and BRAKET_AVAILABLE:
             backend_func = run_braket_simulation

        if backend_func:
            # Run the synchronous backend function in a thread pool
            # Pass the necessary arguments (assuming qasm_file and shots are primary)
            sim_result = await asyncio.to_thread(backend_func, qasm_file=circuit_path, shots=shots)
            logger.info(f"[Task:{job_id}] SDK backend function call completed.")
        else:
            # Should have been caught by endpoint validation, but safety check
            raise RuntimeError(f"{simulator_name} backend requested but not available or supported.")
        # --- End Select and Run ---

        exec_time = time.time() - start_time
        if sim_result and isinstance(sim_result, SimulationResult):
             job["status"] = "COMPLETED"
             # Extract results from the SimulationResult object
             job["results"] = {
                 "success": True,
                 "counts": sim_result.counts,
                 "execution_time_sec": exec_time,
                 "backend_metadata": sim_result.metadata
             }
             logger.info("[Task:%s] SDK backend execution COMPLETED successfully in %.3f seconds.", job_id, exec_time)
        else:
             job["status"] = "FAILED"
             error_message = f"SDK backend for {simulator_name} failed or returned unexpected result: {sim_result}"
             job["error"] = error_message
             logger.error("[Task:%s] SDK backend execution FAILED. Reason: %s", job_id, error_message)

    except Exception as e:
        exec_time = time.time() - start_time
        logger.exception("[Task:%s] Unhandled exception during SDK backend execution after %.3f seconds.", job_id, exec_time)
        job["status"] = "FAILED"
        error_message = f"Unhandled Execution Error: {type(e).__name__}: {str(e)}"
        job["error"] = error_message
        job["results"] = {"success": False, "error": error_message, "execution_time_sec": exec_time}
    finally:
        # Clean up the temporary circuit file
        if os.path.exists(job.get("circuit_path", "")):
            try:
                os.remove(job["circuit_path"])
                logger.debug(f"[Task:{job_id}] Cleaned up temporary circuit file: {job['circuit_path']}")
            except Exception as e:
                logger.warning(f"[Task:{job_id}] Failed to cleanup temp circuit file {job.get('circuit_path')}: {e}")

# --- Main execution block (for running app.py directly) ---
if __name__ == "__main__":
    service_port = int(os.environ.get("PORT", ${port})) # Use template var here
    log_level_str = os.environ.get("LOG_LEVEL", "INFO").upper()
    logger.setLevel(getattr(logging, log_level_str, logging.INFO))
    logger.info("Starting Quantum Microservice '%s' v%s directly on port %d", SERVICE_TITLE, SERVICE_VERSION, service_port)
    # Use uvicorn for running the FastAPI app
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=service_port, log_level=log_level_str.lower())
